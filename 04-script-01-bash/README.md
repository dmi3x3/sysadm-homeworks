#Домашнее задание к занятию "4.1. Командная оболочка Bash: Практические навыки"
##Обязательные задания
1. Есть скрипт:
    ```shell
    a=1
    b=2
    c=a+b
    d=$a+$b
    e=$(($a+$b))
    ```
    Какие значения переменным c,d,e будут присвоены?
    Почему?
    Ответ:
    ```shell
    c=a+b - (происходит сложение двух строк a и b т.к. они записаны, не как переменные)
    d=1+2 - (происходит сложение строк, записанных в переменные a и b, результат - строка 1+2)
    e=3   - (происходит сложение чисел, записанных в переменные a и b, как строки, результат - число 3)
    ```
    
2. На нашем локальном сервере упал сервис и мы написали скрипт, который постоянно проверяет его доступность, записывая дату проверок до тех пор, пока сервис не станет доступным. В скрипте допущена ошибка, из-за которой выполнение не может завершиться, при этом место на Жёстком Диске постоянно уменьшается. Что необходимо сделать, чтобы его исправить:

    ```shell
    while ((1==1)
        do
            curl https://localhost:4757
            if (($? != 0))
            then
                date >> curl.log
            fi
        done
    ```
    Ответ:
    Ошибка заключается в том, что в первой строке, в условии нет второй закрывающей скобки.
    Также в данном случае скорость заполнения файла (curl.log) ограничена скоростью работы процессора и сети, необходимо замедлить работу скрипта до разумных пределов, например проверять доступность раз в 5 секунд (sleep 5).
    Еще надо добавить возможность завершения скрипта (else exit), при возобновлении доступности сервиса.
    Окончательно скрипт может выглядеть так:
    ```shell
    while ((1==1))
        do
            curl https://localhost:4757
            if (($? != 0))
            then
                date >> curl.log
            else exit
            fi
            sleep 5
        done
    ```

3. Необходимо написать скрипт, который проверяет доступность трёх IP: 192.168.0.1, 173.194.222.113, 87.250.250.242 по 80 порту и записывает результат в файл log. Проверять доступность необходимо пять раз для каждого узла.

   ```shell
    ipaddrs=(192.168.0.1 173.194.222.113 87.250.250.242)
    timeout=5
    for i in {1..5}
        do
        date >> curl2.log
            for a in ${ipaddrs[@]}
                do
                    curl -Is --connect-timeout $timeout $a:80 > /dev/null
                    echo "IP Addr: $a status: $?" >> curl2.log
                done
	    sleep 2
        done
    ```


4. Необходимо дописать скрипт из предыдущего задания так, чтобы он выполнялся до тех пор, пока один из узлов не окажется недоступным. Если любой из узлов недоступен - IP этого узла пишется в файл error, скрипт прерывается
    Ответ:
    
    ```shell
    ipaddrs=(192.168.0.1 173.194.222.113 87.250.250.242)
    timeout=5
    status_ip=0
    while ((1 == 1))
    do
    date >> curl2.log
        for a in ${ipaddrs[@]}
        do
           curl -Is --connect-timeout $timeout $a:80 > /dev/null
           status_ip=$?
        echo "Host: $a status: $status_ip" >> curl2.log
           if (($status_ip != 0))
           then
               echo "IP: $a status: $status_ip" >> error.log
               exit
           fi
        done
    done
    ```
    Столкнулся с тем, что условие в цикле while (($status_ip == 0)) не подходит для задачи, т.к. оно остановит скрипт только в том случае, когда недоступен будет последний ip в массиве. А exit в if then, как раз останавливает скрипт после проявления недоступности и записи об этом в error.     

##Дополнительное задание (со звездочкой*) - необязательно к выполнению

1. Мы хотим, чтобы у нас были красивые сообщения для коммитов в репозиторий. Для этого нужно написать локальный хук для git, который будет проверять, что сообщение в коммите содержит код текущего задания в квадратных скобках и количество символов в сообщении не превышает 30. Пример сообщения: [04-script-01-bash] сломал хук.
    Ответ:

    ```shell
    dmitriy@dellix:~/netology/git-hooks-test$ cat .git/hooks/commit-msg 
    #!/bin/sh
    MSG_FILE=$1
    FILE_CONTENT="$(cat $MSG_FILE)"
    # Initialize constants here
    export REGEX='(\[[0-9]{2}-[A-Za-z0-9_]{1,10}-[0-9]{2}-[A-Za-z0-9_]{1,10}\]).*'
    export ERROR_MSG="Commit message format must match regex \"${REGEX}\""
    if [[ $FILE_CONTENT =~ $REGEX ]] && (( ${#FILE_CONTENT} <= 30 )); then
        echo Nice commit! $FILE_CONTENT lenght: ${#FILE_CONTENT} jira_ticket: ${BASH_REMATCH[1]}
    else
        echo \"$FILE_CONTENT\" lenght: ${#FILE_CONTENT} сломал хук
        echo $ERROR_MSG
        exit 1
    fi
    exit 0
    ```
    Хук commit-msg вызывается после того, как вы ввели commit message. Это, хорошая возможность выдать предупреждение разработчикам о том, что сообщение commit’a не соответствует принятым стандартам.
    При неправильном формате сообщения, логичнее выдавать его целиком, т.к. если оно не подходит под регулярное выражение, в сообщении об ошибке будет только "сломал хук" 